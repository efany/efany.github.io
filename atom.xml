<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>efan的个人博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-03-13T18:17:02.643Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>efan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试题J2SE学习笔记</title>
    <link href="http://yoursite.com/2016/03/14/%E9%9D%A2%E8%AF%95%E9%A2%98J2SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/03/14/面试题J2SE学习笔记/</id>
    <published>2016-03-13T18:16:58.000Z</published>
    <updated>2016-03-13T18:17:02.643Z</updated>
    
    <content type="html">&lt;p&gt;这篇博文主要是关于面试中常见的J2SE题的学习笔记，哎，这一部分是我比较薄弱的地方了，不过这些知识点对于开发尤其重要，好好学习，增强自身实力，嘿嘿。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;1-九种基本数据类型的大小，以及他们的封装类。&quot;&gt;&lt;a href=&quot;#1-九种基本数据类型的大小，以及他们的封装类。&quot; class=&quot;headerlink&quot; title=&quot;1.九种基本数据类型的大小，以及他们的封装类。&quot;&gt;&lt;/a&gt;1.九种基本数据类型的大小，以及他们的封装类。&lt;/h4&gt;&lt;p&gt;基本数据类型可以分为四类，字符类型char，布尔类型boolean，空类型void以及数值类型byte、short、int、long、float、double。数值类型又可以分为整数类型byte、short、int、long和浮点数类型float、double。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;简单类型&lt;/th&gt;
&lt;th&gt;位数&lt;/th&gt;
&lt;th&gt;表示范围&lt;/th&gt;
&lt;th&gt;封装类&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;void&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;–&lt;/td&gt;
&lt;td&gt;Void&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;-128~127&lt;/td&gt;
&lt;td&gt;Byte&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;true/false&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;存储Unicode码&lt;/td&gt;
&lt;td&gt;Character&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;-32768~32767&lt;/td&gt;
&lt;td&gt;Short&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Int&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;负的2的31次方到正的2的31次方减1&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;负的2的63次方到正的2的63次方减1&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;1.4E-45~3.4028235E38&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;4.9e-324~1.8e308&lt;/td&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;2-Switch能否用string做参数&quot;&gt;&lt;a href=&quot;#2-Switch能否用string做参数&quot; class=&quot;headerlink&quot; title=&quot;2.Switch能否用string做参数&quot;&gt;&lt;/a&gt;2.Switch能否用string做参数&lt;/h4&gt;&lt;p&gt;在java7之前switch只支持byte、short、char、int、integer、enum枚举类型，java7后switch支持String作为参数了。&lt;/p&gt;
&lt;h4 id=&quot;3-equals与-的区别。&quot;&gt;&lt;a href=&quot;#3-equals与-的区别。&quot; class=&quot;headerlink&quot; title=&quot;3.equals与==的区别。&quot;&gt;&lt;/a&gt;3.equals与==的区别。&lt;/h4&gt;&lt;p&gt;==比较的是两个数据的内存地址是否相同，equals比较的是两个数据的内存地址存储的值是否相同。对于基本类型两者效果一样，但是对于对象就不同了。&lt;/p&gt;
&lt;h4 id=&quot;5-Object有哪些公用方法？&quot;&gt;&lt;a href=&quot;#5-Object有哪些公用方法？&quot; class=&quot;headerlink&quot; title=&quot;5.Object有哪些公用方法？&quot;&gt;&lt;/a&gt;5.Object有哪些公用方法？&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;th&gt;简介&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;public final Class&amp;lt;? extends Object&amp;gt; getClass()&lt;/td&gt;
&lt;td&gt;Returns the runtime class of this. The returned object is the object that is locked by {@code  static synchronized} methods of the represented class.&lt;/td&gt;
&lt;td&gt;返回一个对象的运行时类。该 Class 对象是由所表示类的 static synchronized 方法锁定的对象。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;protected Object clone()&lt;/td&gt;
&lt;td&gt;Creates and returns a copy of this object.&lt;/td&gt;
&lt;td&gt;首先，使用这个方法的类必须实现java.lang.Cloneable接口，否则会抛出CloneNotSupportedException异常。Cloneable接口中不包含任何方法，所以实现它时只要在类声明中加上implements语句即可。第二个比较特殊的地方在于这个方法是protected修饰的，覆写clone()方法的时候需要写成public，才能让类外部的代码调用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public boolean equals(Object obj)&lt;/td&gt;
&lt;td&gt;Indicates whether some other object is “equal to” this one.&lt;/td&gt;
&lt;td&gt;　对于Object类的equals()方法来说，它判断调用equals()方法的引用于传进来的引用是否一致，即这两个引用是否指向的是同一个对象。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public int hashCode()&lt;/td&gt;
&lt;td&gt;Returns a hash code value for the object.&lt;/td&gt;
&lt;td&gt;当你覆写（override）了equals()方法之后，必须也覆写hashCode()方法，反之亦然。这个方法返回一个整型值（hash code value），如果两个对象被equals()方法判断为相等，那么它们就应该拥有同样的hash code。Object类的hashCode()方法为不同的对象返回不同的值，Object类的hashCode值表示的是对象的地址。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public String toString()&lt;/td&gt;
&lt;td&gt;　Returns a string representation of the object.&lt;/td&gt;
&lt;td&gt;当打印引用，如调用System.out.println()时，会自动调用对象的toString()方法，打印出引用所指的对象的toString()方法的返回值，因为每个类都直接或间接地继承自Object，因此每个类都有toString()方法。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public final void notify()&lt;/td&gt;
&lt;td&gt;Wakes up a single thread that is waiting on this object’s monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. A thread waits on an object’s monitor by calling one of the {@code wait} methods.&lt;/td&gt;
&lt;td&gt;此方法只应由作为此对象监视器的所有者的线程来调用。通过以下三种方法之一，线程可以成为此对象监视器的所有者：1.通过执行此对象的同步 (Sychronized) 实例方法。2.通过执行在此对象上进行同步的 synchronized 语句的正文。3.对于 Class 类型的对象，可以通过执行该类的同步静态方法。一次只能有一个线程拥有对象的监视器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public final void notifyAll()&lt;/td&gt;
&lt;td&gt;Causes the current thread to wait until either another thread invokes the {@link java.lang.Object#notify()} method or the {@link java.lang.Object#notifyAll()} method for this object, or a specified amount of time has elapsed.&lt;/td&gt;
&lt;td&gt;此方法只应由作为此对象监视器的所有者的线程来调用。请参阅 notify 方法，了解线程能够成为监视器所有者的方法的描述。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public final void wait(long timeout)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public final void wait(long timeout, int nanos)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public final void wait()&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。换句话说，此方法的行为就好像它仅执行 wait(0) 调用一样。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;protected void finalize()&lt;/td&gt;
&lt;td&gt;Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the {@code finalize} method to dispose of system resources or to perform other cleanup.&lt;/td&gt;
&lt;td&gt;finalize 的常规协定是：当 JavaTM 虚拟机已确定尚未终止的任何线程无法再通过任何方法访问此对象时，将调用此方法，除非由于准备终止的其他某个对象或类的终结操作执行了某个操作。finalize 方法可以采取任何操作，其中包括再次使此对象对其他线程可用；不过，finalize 的主要目的是在不可撤消地丢弃对象之前执行清除操作。例如，表示输入/输出连接的对象的 finalize 方法可执行显式 I/O 事务，以便在永久丢弃对象之前中断连接。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文主要是关于面试中常见的J2SE题的学习笔记，哎，这一部分是我比较薄弱的地方了，不过这些知识点对于开发尤其重要，好好学习，增强自身实力，嘿嘿。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试题Android学习笔记</title>
    <link href="http://yoursite.com/2016/03/13/%E9%9D%A2%E8%AF%95%E9%A2%98Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/03/13/面试题Android学习笔记/</id>
    <published>2016-03-13T09:22:15.000Z</published>
    <updated>2016-03-13T18:16:32.966Z</updated>
    
    <content type="html">&lt;p&gt;这段时间一边要忙着几个项目，一边还得忙着找实习，有空就得多看看面试题，恶补一下基础知识。之前一直都是用各种第三方库，导致基础知识严重不足，这段时间好好恶补下，我也不想特别功利的背知识点，就尽可能去好好理解学习，顺便就写点学习笔记什么的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Android的消息机制&quot;&gt;&lt;a href=&quot;#Android的消息机制&quot; class=&quot;headerlink&quot; title=&quot;Android的消息机制&quot;&gt;&lt;/a&gt;Android的消息机制&lt;/h4&gt;&lt;hr&gt;
&lt;h5 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h5&gt;&lt;p&gt;Android的消息处理机制主要是指Handler的运行机制以及附带的MessageQueue和Looper的工作过程。再加上一个ThreadLocal的用法。&lt;/p&gt;
&lt;h5 id=&quot;Handler&quot;&gt;&lt;a href=&quot;#Handler&quot; class=&quot;headerlink&quot; title=&quot;Handler&quot;&gt;&lt;/a&gt;Handler&lt;/h5&gt;&lt;p&gt;A Handler allows you to send and process Message and Runnable objects associated with a thread’s MessageQueue. Each Handler instance is associated with a single thread and that thread’s message queue. When you create a new Handler, it is bound to the thread / message queue of the thread that is creating it – from that point on, it will deliver messages and runnables to that message queue and execute them as they come out of the message queue.&lt;/p&gt;
&lt;p&gt;There are two main uses for a Handler: (1) to schedule messages and runnables to be executed as some point in the future; and (2) to enqueue an action to be performed on a different thread than your own.&lt;/p&gt;
&lt;p&gt;Handler的主要是发送（send）和接收消息（Message）与发送（post）和接收Runable，其实就是都是对于Message的操作，因为post（Runable）时也是实现了发送了一条Callback为Runable的Message来实现的。&lt;/p&gt;
&lt;p&gt;handler的send和post方法都是向消息队列（MessageQueue）插入了一条消息（Message），然后MessageQueue的next方法就返回这条消息给Looper，Looper收到消息后交给Handler处理。&lt;/p&gt;
&lt;h5 id=&quot;Message与MessageQueue&quot;&gt;&lt;a href=&quot;#Message与MessageQueue&quot; class=&quot;headerlink&quot; title=&quot;Message与MessageQueue&quot;&gt;&lt;/a&gt;Message与MessageQueue&lt;/h5&gt;&lt;p&gt;Message是线程之间传递信息的载体，包含了对消息的描述和任意的数据对象。Message中包含了两个额外的 int字段和一个object字段，这样在大部分情况下，使用者就不需要再做内存分配工作了。虽然Message的构造函数是public的，但是最好是使用Message.obtain( )或Handler.obtainMessage( )函数来获取Message对象，因为Message的实现中包含了回收再利用的机制，可以提供效率。&lt;/p&gt;
&lt;p&gt;MessageQueue是指消息队列，是一个单链表，因为方便插入与读取，插入和读取对应的方法是enqueueMessage和next，其中next是一个无限循环，如果队列中没有消息，那么next机会阻塞在哪里，当有新消息就返回消息并且从队列中移除。&lt;/p&gt;
&lt;h5 id=&quot;Looper&quot;&gt;&lt;a href=&quot;#Looper&quot; class=&quot;headerlink&quot; title=&quot;Looper&quot;&gt;&lt;/a&gt;Looper&lt;/h5&gt;&lt;p&gt;Looper实现的事消息循环的功能，会不停的查看MessageQueue中是否有新消息，如果有新消息就立刻处理。Handler的工作必须有Looper，使用Looper.prepare()可以为线程创建一个Looper，接着使用Looper.loop()来开启消息循环。在ActivityThread中默认执行了prepareMainLooper()方法，&lt;/p&gt;
&lt;h5 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h5&gt;&lt;p&gt;Implements a thread-local storage, that is, a variable for which each thread has its own value. All threads share the same ThreadLocal object, but each sees a different value when accessing it, and changes made by one thread do not affect the other threads. The implementation supports null values.&lt;/p&gt;
&lt;p&gt;ThreadLocal是一个线程内部的数据存储类，它存在的意义就在于如果没有这样一个类，那么多个线程同时访问一个数据就可能出现不可预料的情况，相对于锁机制的时间换空间,ThreadLocal相当于空间换时间，有其优势。&lt;/p&gt;
&lt;p&gt;ThreadLocal实现原理就是对于每一个数据建立了一个Object[]   table数组，每次存放读取都是操作线程相对应的数据。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这段时间一边要忙着几个项目，一边还得忙着找实习，有空就得多看看面试题，恶补一下基础知识。之前一直都是用各种第三方库，导致基础知识严重不足，这段时间好好恶补下，我也不想特别功利的背知识点，就尽可能去好好理解学习，顺便就写点学习笔记什么的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>个人博客搭建之Github篇</title>
    <link href="http://yoursite.com/2016/03/11/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8BGithub%E7%AF%87/"/>
    <id>http://yoursite.com/2016/03/11/个人博客搭建之Github篇/</id>
    <published>2016-03-11T14:34:34.000Z</published>
    <updated>2016-03-13T14:26:57.441Z</updated>
    
    <content type="html">&lt;p&gt;其实搭建博客和git没什么太大关系，只要有github账号就可以了，但是既然提到了就简单了解一下git和github&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;术语&quot;&gt;&lt;a href=&quot;#术语&quot; class=&quot;headerlink&quot; title=&quot;术语&quot;&gt;&lt;/a&gt;术语&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;术语&lt;/th&gt;
&lt;th&gt;定义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;仓库 Repository&lt;/td&gt;
&lt;td&gt;一个仓库包括了所有的版本信息、所有的分支和标记信息.在Git中仓库的每份拷贝都是完整的。仓库让你可以从中取得你的工作副本。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;分支 Branches&lt;/td&gt;
&lt;td&gt;一个分支意味着一个独立的、拥有自己历史信息的代码线分支（codeline）。你可以从已有的代码中生成一个新的分支，这个分支与剩余的分支完全独立。默认的分支往往是叫master。用户可以选择一个分支，选择一个分支叫做checkout.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;标记 Tags&lt;/td&gt;
&lt;td&gt;一个标记指的是某个分支某个特定时间点的状态。通过标记，可以很方便的切换到标记时的状态，例如2009年1月25号在testing分支上的代码状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;提交 Commit&lt;/td&gt;
&lt;td&gt;提交代码后，仓库会创建一个新的版本。这个版本可以在后续被重新获得。每次提交都包括作者和提交者，作者和提交者可以是不同的人&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;URL&lt;/td&gt;
&lt;td&gt;URl用来标识一个仓库的位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;修订 Revision&lt;/td&gt;
&lt;td&gt;用来表示代码的一个版本状态。Git通过用SHA1 hash算法表示的id来标识不同的版本。每一个 SHA1 id都是160位长,16进制标识的字符串.最新的版本可以通过HEAD来获取.之前的版本可以通过”HEAD~1”来获取，以此类推。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;忽略特定的文件&quot;&gt;&lt;a href=&quot;#忽略特定的文件&quot; class=&quot;headerlink&quot; title=&quot;忽略特定的文件&quot;&gt;&lt;/a&gt;忽略特定的文件&lt;/h2&gt;&lt;p&gt;可以配置Git忽略特定的文件或者是文件夹。这些配置都放在.gitignore文件中。这个文件可以存在于不同的文件夹中，可以包含不同的文件匹配模式。为了让Git忽略bin文件夹，在主目录下放置.gitignore文件，其中内容为bin。&lt;br&gt;同时Git也提供了全局的配置，core.excludesfile。&lt;br&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;*.iml&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.gradle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/local.properties&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/.idea/workspace.xml&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/.idea/libraries&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.DS_Store&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/build&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/captures&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;具体的git教程参照&lt;a href=&quot;http://blog.csdn.net/lishuo_os_ds/article/details/8078475#sec-1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub详细教程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Android-Studio的git功能&quot;&gt;&lt;a href=&quot;#Android-Studio的git功能&quot; class=&quot;headerlink&quot; title=&quot;Android Studio的git功能&quot;&gt;&lt;/a&gt;Android Studio的git功能&lt;/h2&gt;&lt;h6 id=&quot;1-注册github账号&quot;&gt;&lt;a href=&quot;#1-注册github账号&quot; class=&quot;headerlink&quot; title=&quot;1.注册github账号&quot;&gt;&lt;/a&gt;1.注册github账号&lt;/h6&gt;&lt;p&gt;自行百度 Google&lt;/p&gt;
&lt;h6 id=&quot;1-下载安装git&quot;&gt;&lt;a href=&quot;#1-下载安装git&quot; class=&quot;headerlink&quot; title=&quot;1.下载安装git&quot;&gt;&lt;/a&gt;1.下载安装git&lt;/h6&gt;&lt;p&gt;地址：&lt;a href=&quot;https://git-scm.com/downloads&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://git-scm.com/downloads&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&quot;2-匹配到AS&quot;&gt;&lt;a href=&quot;#2-匹配到AS&quot; class=&quot;headerlink&quot; title=&quot;2.匹配到AS&quot;&gt;&lt;/a&gt;2.匹配到AS&lt;/h6&gt;&lt;p&gt;File–&amp;gt;Setting–&amp;gt;Version Control–&amp;gt;Git–&amp;gt;PAth to Git executable:&lt;/p&gt;
&lt;p&gt;注意是Git/bin/git.exe&lt;/p&gt;
&lt;h6 id=&quot;3-使用&quot;&gt;&lt;a href=&quot;#3-使用&quot; class=&quot;headerlink&quot; title=&quot;3.使用&quot;&gt;&lt;/a&gt;3.使用&lt;/h6&gt;&lt;ol&gt;
&lt;li&gt;VCS–&amp;gt;enable….–&amp;gt;选择git&lt;/li&gt;
&lt;li&gt;右击工程（注意选到project目录模式）或者VCS–&amp;gt;Git–&amp;gt;add&lt;/li&gt;
&lt;li&gt;Git–&amp;gt;commit Directory–&amp;gt;选择要上传的文件&lt;/li&gt;
&lt;li&gt;输入Commit Message点击Commit&lt;/li&gt;
&lt;li&gt;如果是第一次上传直接push，填写地址，然后输入账号密码就好了&lt;/li&gt;
&lt;li&gt;如果是协同的话记得先pull解决冲突再push&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;其实搭建博客和git没什么太大关系，只要有github账号就可以了，但是既然提到了就简单了解一下git和github&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>

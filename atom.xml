<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>efan的个人博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-03-13T18:22:46.187Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>efan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试题J2SE学习笔记</title>
    <link href="http://yoursite.com/2016/03/14/%E9%9D%A2%E8%AF%95%E9%A2%98J2SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/03/14/面试题J2SE学习笔记/</id>
    <published>2016-03-13T18:16:58.000Z</published>
    <updated>2016-03-13T18:22:46.187Z</updated>
    
    <content type="html">&lt;p&gt;这篇博文主要是关于面试中常见的J2SE题的学习笔记，哎，这一部分是我比较薄弱的地方了，不过这些知识点对于开发尤其重要，好好学习，增强自身实力，嘿嘿。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;九种基本数据类型的大小，以及他们的封装类。&quot;&gt;&lt;a href=&quot;#九种基本数据类型的大小，以及他们的封装类。&quot; class=&quot;headerlink&quot; title=&quot;九种基本数据类型的大小，以及他们的封装类。&quot;&gt;&lt;/a&gt;九种基本数据类型的大小，以及他们的封装类。&lt;/h4&gt;&lt;p&gt;基本数据类型可以分为四类，字符类型char，布尔类型boolean，空类型void以及数值类型byte、short、int、long、float、double。数值类型又可以分为整数类型byte、short、int、long和浮点数类型float、double。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;简单类型&lt;/th&gt;
&lt;th&gt;位数&lt;/th&gt;
&lt;th&gt;表示范围&lt;/th&gt;
&lt;th&gt;封装类&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;void&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;–&lt;/td&gt;
&lt;td&gt;Void&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;-128~127&lt;/td&gt;
&lt;td&gt;Byte&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;true/false&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;存储Unicode码&lt;/td&gt;
&lt;td&gt;Character&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;-32768~32767&lt;/td&gt;
&lt;td&gt;Short&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Int&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;负的2的31次方到正的2的31次方减1&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;负的2的63次方到正的2的63次方减1&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;1.4E-45~3.4028235E38&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;4.9e-324~1.8e308&lt;/td&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;Switch能否用string做参数&quot;&gt;&lt;a href=&quot;#Switch能否用string做参数&quot; class=&quot;headerlink&quot; title=&quot;Switch能否用string做参数&quot;&gt;&lt;/a&gt;Switch能否用string做参数&lt;/h4&gt;&lt;p&gt;在java7之前switch只支持byte、short、char、int、integer、enum枚举类型，java7后switch支持String作为参数了。&lt;/p&gt;
&lt;h4 id=&quot;equals与-的区别。&quot;&gt;&lt;a href=&quot;#equals与-的区别。&quot; class=&quot;headerlink&quot; title=&quot;equals与==的区别。&quot;&gt;&lt;/a&gt;equals与==的区别。&lt;/h4&gt;&lt;p&gt;==比较的是两个数据的内存地址是否相同，equals在Object类里比较的也是数据的内存地址，但是很多类都覆盖了该方法，比较的是两个数据的内存地址存储的值是否相同。对于基本类型两者效果一样，但是对于覆盖equals的类就不同了。&lt;/p&gt;
&lt;h4 id=&quot;Object有哪些公用方法？&quot;&gt;&lt;a href=&quot;#Object有哪些公用方法？&quot; class=&quot;headerlink&quot; title=&quot;Object有哪些公用方法？&quot;&gt;&lt;/a&gt;Object有哪些公用方法？&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;th&gt;简介&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;public final Class&amp;lt;? extends Object&amp;gt; getClass()&lt;/td&gt;
&lt;td&gt;Returns the runtime class of this. The returned object is the object that is locked by {@code  static synchronized} methods of the represented class.&lt;/td&gt;
&lt;td&gt;返回一个对象的运行时类。该 Class 对象是由所表示类的 static synchronized 方法锁定的对象。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;protected Object clone()&lt;/td&gt;
&lt;td&gt;Creates and returns a copy of this object.&lt;/td&gt;
&lt;td&gt;首先，使用这个方法的类必须实现java.lang.Cloneable接口，否则会抛出CloneNotSupportedException异常。Cloneable接口中不包含任何方法，所以实现它时只要在类声明中加上implements语句即可。第二个比较特殊的地方在于这个方法是protected修饰的，覆写clone()方法的时候需要写成public，才能让类外部的代码调用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public boolean equals(Object obj)&lt;/td&gt;
&lt;td&gt;Indicates whether some other object is “equal to” this one.&lt;/td&gt;
&lt;td&gt;　对于Object类的equals()方法来说，它判断调用equals()方法的引用于传进来的引用是否一致，即这两个引用是否指向的是同一个对象。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public int hashCode()&lt;/td&gt;
&lt;td&gt;Returns a hash code value for the object.&lt;/td&gt;
&lt;td&gt;当你覆写（override）了equals()方法之后，必须也覆写hashCode()方法，反之亦然。这个方法返回一个整型值（hash code value），如果两个对象被equals()方法判断为相等，那么它们就应该拥有同样的hash code。Object类的hashCode()方法为不同的对象返回不同的值，Object类的hashCode值表示的是对象的地址。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public String toString()&lt;/td&gt;
&lt;td&gt;　Returns a string representation of the object.&lt;/td&gt;
&lt;td&gt;当打印引用，如调用System.out.println()时，会自动调用对象的toString()方法，打印出引用所指的对象的toString()方法的返回值，因为每个类都直接或间接地继承自Object，因此每个类都有toString()方法。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public final void notify()&lt;/td&gt;
&lt;td&gt;Wakes up a single thread that is waiting on this object’s monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. A thread waits on an object’s monitor by calling one of the {@code wait} methods.&lt;/td&gt;
&lt;td&gt;此方法只应由作为此对象监视器的所有者的线程来调用。通过以下三种方法之一，线程可以成为此对象监视器的所有者：1.通过执行此对象的同步 (Sychronized) 实例方法。2.通过执行在此对象上进行同步的 synchronized 语句的正文。3.对于 Class 类型的对象，可以通过执行该类的同步静态方法。一次只能有一个线程拥有对象的监视器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public final void notifyAll()&lt;/td&gt;
&lt;td&gt;Causes the current thread to wait until either another thread invokes the {@link java.lang.Object#notify()} method or the {@link java.lang.Object#notifyAll()} method for this object, or a specified amount of time has elapsed.&lt;/td&gt;
&lt;td&gt;此方法只应由作为此对象监视器的所有者的线程来调用。请参阅 notify 方法，了解线程能够成为监视器所有者的方法的描述。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public final void wait(long timeout)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public final void wait(long timeout, int nanos)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public final void wait()&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。换句话说，此方法的行为就好像它仅执行 wait(0) 调用一样。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;protected void finalize()&lt;/td&gt;
&lt;td&gt;Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the {@code finalize} method to dispose of system resources or to perform other cleanup.&lt;/td&gt;
&lt;td&gt;finalize 的常规协定是：当 JavaTM 虚拟机已确定尚未终止的任何线程无法再通过任何方法访问此对象时，将调用此方法，除非由于准备终止的其他某个对象或类的终结操作执行了某个操作。finalize 方法可以采取任何操作，其中包括再次使此对象对其他线程可用；不过，finalize 的主要目的是在不可撤消地丢弃对象之前执行清除操作。例如，表示输入/输出连接的对象的 finalize 方法可执行显式 I/O 事务，以便在永久丢弃对象之前中断连接。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文主要是关于面试中常见的J2SE题的学习笔记，哎，这一部分是我比较薄弱的地方了，不过这些知识点对于开发尤其重要，好好学习，增强自身实力，嘿嘿。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android面试题学习笔记</title>
    <link href="http://yoursite.com/2016/03/12/%E9%9D%A2%E8%AF%95%E9%A2%98Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/03/12/面试题Android学习笔记/</id>
    <published>2016-03-12T13:54:24.000Z</published>
    <updated>2016-03-14T14:07:44.256Z</updated>
    
    <content type="html">&lt;p&gt;这段时间一边要忙着几个项目，一边还得忙着找实习，有空就得多看看面试题，恶补一下基础知识。之前一直都是用各种第三方库，导致基础知识严重不足，这段时间好好恶补下，我也不想特别功利的背知识点，就尽可能去好好理解学习，顺便就写点学习笔记什么的。&lt;/p&gt;
&lt;h4 id=&quot;Android的消息机制&quot;&gt;&lt;a href=&quot;#Android的消息机制&quot; class=&quot;headerlink&quot; title=&quot;Android的消息机制&quot;&gt;&lt;/a&gt;Android的消息机制&lt;/h4&gt;&lt;hr&gt;
&lt;h5 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h5&gt;&lt;p&gt;Android的消息处理机制主要是指Handler的运行机制以及附带的MessageQueue和Looper的工作过程。再加上一个ThreadLocal的用法。&lt;/p&gt;
&lt;h5 id=&quot;Handler&quot;&gt;&lt;a href=&quot;#Handler&quot; class=&quot;headerlink&quot; title=&quot;Handler&quot;&gt;&lt;/a&gt;Handler&lt;/h5&gt;&lt;p&gt;A Handler allows you to send and process Message and Runnable objects associated with a thread’s MessageQueue. Each Handler instance is associated with a single thread and that thread’s message queue. When you create a new Handler, it is bound to the thread / message queue of the thread that is creating it – from that point on, it will deliver messages and runnables to that message queue and execute them as they come out of the message queue.&lt;/p&gt;
&lt;p&gt;There are two main uses for a Handler: (1) to schedule messages and runnables to be executed as some point in the future; and (2) to enqueue an action to be performed on a different thread than your own.&lt;/p&gt;
&lt;p&gt;Handler的主要是发送（send）和接收消息（Message）与发送（post）和接收Runable，其实就是都是对于Message的操作，因为post（Runable）时也是实现了发送了一条Callback为Runable的Message来实现的。&lt;/p&gt;
&lt;p&gt;handler的send和post方法都是向消息队列（MessageQueue）插入了一条消息（Message），然后MessageQueue的next方法就返回这条消息给Looper，Looper收到消息后交给Handler处理。&lt;/p&gt;
&lt;h5 id=&quot;Message与MessageQueue&quot;&gt;&lt;a href=&quot;#Message与MessageQueue&quot; class=&quot;headerlink&quot; title=&quot;Message与MessageQueue&quot;&gt;&lt;/a&gt;Message与MessageQueue&lt;/h5&gt;&lt;p&gt;Message是线程之间传递信息的载体，包含了对消息的描述和任意的数据对象。Message中包含了两个额外的 int字段和一个object字段，这样在大部分情况下，使用者就不需要再做内存分配工作了。虽然Message的构造函数是public的，但是最好是使用Message.obtain( )或Handler.obtainMessage( )函数来获取Message对象，因为Message的实现中包含了回收再利用的机制，可以提供效率。&lt;/p&gt;
&lt;p&gt;MessageQueue是指消息队列，是一个单链表，因为方便插入与读取，插入和读取对应的方法是enqueueMessage和next，其中next是一个无限循环，如果队列中没有消息，那么next机会阻塞在哪里，当有新消息就返回消息并且从队列中移除。&lt;/p&gt;
&lt;h5 id=&quot;Looper&quot;&gt;&lt;a href=&quot;#Looper&quot; class=&quot;headerlink&quot; title=&quot;Looper&quot;&gt;&lt;/a&gt;Looper&lt;/h5&gt;&lt;p&gt;Looper实现的事消息循环的功能，会不停的查看MessageQueue中是否有新消息，如果有新消息就立刻处理。Handler的工作必须有Looper，使用Looper.prepare()可以为线程创建一个Looper，接着使用Looper.loop()来开启消息循环。在ActivityThread中默认执行了prepareMainLooper()方法，&lt;/p&gt;
&lt;h5 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h5&gt;&lt;p&gt;Implements a thread-local storage, that is, a variable for which each thread has its own value. All threads share the same ThreadLocal object, but each sees a different value when accessing it, and changes made by one thread do not affect the other threads. The implementation supports null values.&lt;/p&gt;
&lt;p&gt;ThreadLocal是一个线程内部的数据存储类，它存在的意义就在于如果没有这样一个类，那么多个线程同时访问一个数据就可能出现不可预料的情况，相对于锁机制的时间换空间,ThreadLocal相当于空间换时间，有其优势。&lt;/p&gt;
&lt;p&gt;ThreadLocal实现原理就是对于每一个数据建立了一个Object[]   table数组，每次存放读取都是操作线程相对应的数据。&lt;/p&gt;
&lt;h4 id=&quot;Android的进程、线程和线程池&quot;&gt;&lt;a href=&quot;#Android的进程、线程和线程池&quot; class=&quot;headerlink&quot; title=&quot;Android的进程、线程和线程池&quot;&gt;&lt;/a&gt;Android的进程、线程和线程池&lt;/h4&gt;&lt;hr&gt;
&lt;h5 id=&quot;进程与线程的区别和联系&quot;&gt;&lt;a href=&quot;#进程与线程的区别和联系&quot; class=&quot;headerlink&quot; title=&quot;进程与线程的区别和联系&quot;&gt;&lt;/a&gt;进程与线程的区别和联系&lt;/h5&gt;&lt;p&gt;进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.&lt;/p&gt;
&lt;p&gt;线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.&lt;/p&gt;
&lt;p&gt;一个进程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行。相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。&lt;/p&gt;
&lt;p&gt;进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。&lt;br&gt;1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.&lt;br&gt;2) 线程的划分尺度小于进程，使得多线程程序的并发性高。&lt;br&gt;3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。&lt;br&gt;4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。&lt;br&gt;5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。&lt;/p&gt;
&lt;h5 id=&quot;AsyncTask&quot;&gt;&lt;a href=&quot;#AsyncTask&quot; class=&quot;headerlink&quot; title=&quot;AsyncTask&quot;&gt;&lt;/a&gt;AsyncTask&lt;/h5&gt;&lt;p&gt;AsyncTask是一种轻量级的异步任务类型，它可以再线程池中执行后台任务，然后把执行的进度和结果传递给主线程并更新UI，AsyncTask封装了Thread和Handler，并且通过AsyncTask可以很方便的执行后台任务并且在主线程中访问UI。&lt;/p&gt;
&lt;p&gt;必须在主线程中加载，对象必须在UI线程中调用，只能执行一次，Android1.6前是串行执行任务，1.6~3.0是采用在线程池了并行执行，3.0后改为串行执行，但是通过executeOnExecuter()可以并行执行。&lt;/p&gt;
&lt;h5 id=&quot;HandlerThread&quot;&gt;&lt;a href=&quot;#HandlerThread&quot; class=&quot;headerlink&quot; title=&quot;HandlerThread&quot;&gt;&lt;/a&gt;HandlerThread&lt;/h5&gt;&lt;p&gt;HandlerThread继承了Thread，它是一种可以使用Handler的Thread。&lt;/p&gt;
&lt;h5 id=&quot;IntentService&quot;&gt;&lt;a href=&quot;#IntentService&quot; class=&quot;headerlink&quot; title=&quot;IntentService&quot;&gt;&lt;/a&gt;IntentService&lt;/h5&gt;&lt;p&gt;IntentService是一个特殊的Service，IntentService可用于执行后台耗时的任务，由于它是一个服务，所以优先级比较高，不容易被杀死，IntentService封装了HandlerThread和Handler&lt;/p&gt;
&lt;h5 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h5&gt;&lt;p&gt;1) 重用线程池中的线程，避免线程因为创建和销毁所带来的性能开销&lt;br&gt;2) 能有效的控制线程池的最大并发数，避免大量的线程因相互抢占系统资源而导致的堵塞现象&lt;br&gt;3) 能够对线程进行简单的管理，并提供定时执行和制定间隔循环执行等功能&lt;/p&gt;
&lt;p&gt;######ThreadPoolExecutor&lt;br&gt;是线程池的真正实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;corePoolSize - 池中所保存的线程数，包括空闲线程。&lt;br&gt;maximumPoolSize - 池中允许的最大线程数。&lt;br&gt;keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。&lt;br&gt;unit - keepAliveTime 参数的时间单位。&lt;br&gt;workQueue - 执行前用于保持任务的队列。此队列仅保持由 execute 方法提交的 Runnable 任务。&lt;br&gt;threadFactory - 线程工厂，为线程池提供创建新线程的功能。&lt;br&gt;handler - 当线程池无法执行新任务的时候，会调用handler的rejectedExecutionException来通知调用者。&lt;/p&gt;
&lt;h6 id=&quot;FixedThreadPool&quot;&gt;&lt;a href=&quot;#FixedThreadPool&quot; class=&quot;headerlink&quot; title=&quot;FixedThreadPool&quot;&gt;&lt;/a&gt;FixedThreadPool&lt;/h6&gt;&lt;p&gt;是一种线程数量固定的线程池，当线程处于空闲状态时，不会被回收，并且没有超时机制，所以能够快速的响应外界的请求。&lt;/p&gt;
&lt;h6 id=&quot;CachedThreadPool&quot;&gt;&lt;a href=&quot;#CachedThreadPool&quot; class=&quot;headerlink&quot; title=&quot;CachedThreadPool&quot;&gt;&lt;/a&gt;CachedThreadPool&lt;/h6&gt;&lt;p&gt;没有核心线程，但是可以创建任意多个非核心线程，超时时长为60秒。&lt;/p&gt;
&lt;h6 id=&quot;ScheduledThreadPool&quot;&gt;&lt;a href=&quot;#ScheduledThreadPool&quot; class=&quot;headerlink&quot; title=&quot;ScheduledThreadPool&quot;&gt;&lt;/a&gt;ScheduledThreadPool&lt;/h6&gt;&lt;p&gt;核心线程数固定，非核心线程数量无限制，超时时长为，意味着非核心一旦闲置就被回收。&lt;/p&gt;
&lt;h6 id=&quot;SingleThreadExector&quot;&gt;&lt;a href=&quot;#SingleThreadExector&quot; class=&quot;headerlink&quot; title=&quot;SingleThreadExector&quot;&gt;&lt;/a&gt;SingleThreadExector&lt;/h6&gt;&lt;p&gt;只有一个核心线程，是的所有任务顺序执行。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这段时间一边要忙着几个项目，一边还得忙着找实习，有空就得多看看面试题，恶补一下基础知识。之前一直都是用各种第三方库，导致基础知识严重不足，这段时间好好恶补下，我也不想特别功利的背知识点，就尽可能去好好理解学习，顺便就写点学习笔记什么的。&lt;/p&gt;
&lt;h4 id=&quot;Androi
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>个人博客搭建之Github篇</title>
    <link href="http://yoursite.com/2016/03/11/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8BGithub%E7%AF%87/"/>
    <id>http://yoursite.com/2016/03/11/个人博客搭建之Github篇/</id>
    <published>2016-03-11T14:34:34.000Z</published>
    <updated>2016-03-13T16:32:29.679Z</updated>
    
    <content type="html">&lt;p&gt;其实搭建博客和git没什么太大关系，只要有github账号就可以了，但是既然提到了就简单了解一下git和github&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;术语&quot;&gt;&lt;a href=&quot;#术语&quot; class=&quot;headerlink&quot; title=&quot;术语&quot;&gt;&lt;/a&gt;术语&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;术语&lt;/th&gt;
&lt;th&gt;定义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;仓库 Repository&lt;/td&gt;
&lt;td&gt;一个仓库包括了所有的版本信息、所有的分支和标记信息.在Git中仓库的每份拷贝都是完整的。仓库让你可以从中取得你的工作副本。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;分支 Branches&lt;/td&gt;
&lt;td&gt;一个分支意味着一个独立的、拥有自己历史信息的代码线分支（codeline）。你可以从已有的代码中生成一个新的分支，这个分支与剩余的分支完全独立。默认的分支往往是叫master。用户可以选择一个分支，选择一个分支叫做checkout.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;标记 Tags&lt;/td&gt;
&lt;td&gt;一个标记指的是某个分支某个特定时间点的状态。通过标记，可以很方便的切换到标记时的状态，例如2009年1月25号在testing分支上的代码状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;提交 Commit&lt;/td&gt;
&lt;td&gt;提交代码后，仓库会创建一个新的版本。这个版本可以在后续被重新获得。每次提交都包括作者和提交者，作者和提交者可以是不同的人&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;URL&lt;/td&gt;
&lt;td&gt;URl用来标识一个仓库的位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;修订 Revision&lt;/td&gt;
&lt;td&gt;用来表示代码的一个版本状态。Git通过用SHA1 hash算法表示的id来标识不同的版本。每一个 SHA1 id都是160位长,16进制标识的字符串.最新的版本可以通过HEAD来获取.之前的版本可以通过”HEAD~1”来获取，以此类推。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;忽略特定的文件&quot;&gt;&lt;a href=&quot;#忽略特定的文件&quot; class=&quot;headerlink&quot; title=&quot;忽略特定的文件&quot;&gt;&lt;/a&gt;忽略特定的文件&lt;/h2&gt;&lt;p&gt;可以配置Git忽略特定的文件或者是文件夹。这些配置都放在.gitignore文件中。这个文件可以存在于不同的文件夹中，可以包含不同的文件匹配模式。为了让Git忽略bin文件夹，在主目录下放置.gitignore文件，其中内容为bin。&lt;br&gt;同时Git也提供了全局的配置，core.excludesfile。&lt;br&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;*.iml&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.gradle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/local.properties&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/.idea/workspace.xml&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/.idea/libraries&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.DS_Store&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/build&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/captures&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;具体的git教程参照&lt;a href=&quot;http://blog.csdn.net/lishuo_os_ds/article/details/8078475#sec-1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub详细教程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Android-Studio的git功能&quot;&gt;&lt;a href=&quot;#Android-Studio的git功能&quot; class=&quot;headerlink&quot; title=&quot;Android Studio的git功能&quot;&gt;&lt;/a&gt;Android Studio的git功能&lt;/h2&gt;&lt;h6 id=&quot;1-注册github账号&quot;&gt;&lt;a href=&quot;#1-注册github账号&quot; class=&quot;headerlink&quot; title=&quot;1.注册github账号&quot;&gt;&lt;/a&gt;1.注册github账号&lt;/h6&gt;&lt;p&gt;自行百度 Google&lt;/p&gt;
&lt;h6 id=&quot;1-下载安装git&quot;&gt;&lt;a href=&quot;#1-下载安装git&quot; class=&quot;headerlink&quot; title=&quot;1.下载安装git&quot;&gt;&lt;/a&gt;1.下载安装git&lt;/h6&gt;&lt;p&gt;地址：&lt;a href=&quot;https://git-scm.com/downloads&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://git-scm.com/downloads&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&quot;2-匹配到AS&quot;&gt;&lt;a href=&quot;#2-匹配到AS&quot; class=&quot;headerlink&quot; title=&quot;2.匹配到AS&quot;&gt;&lt;/a&gt;2.匹配到AS&lt;/h6&gt;&lt;p&gt;File–&amp;gt;Setting–&amp;gt;Version Control–&amp;gt;Git–&amp;gt;PAth to Git executable:&lt;/p&gt;
&lt;p&gt;注意是Git/bin/git.exe&lt;/p&gt;
&lt;h6 id=&quot;3-使用&quot;&gt;&lt;a href=&quot;#3-使用&quot; class=&quot;headerlink&quot; title=&quot;3.使用&quot;&gt;&lt;/a&gt;3.使用&lt;/h6&gt;&lt;ol&gt;
&lt;li&gt;VCS–&amp;gt;enable….–&amp;gt;选择git&lt;/li&gt;
&lt;li&gt;右击工程（注意选到project目录模式）或者VCS–&amp;gt;Git–&amp;gt;add&lt;/li&gt;
&lt;li&gt;Git–&amp;gt;commit Directory–&amp;gt;选择要上传的文件&lt;/li&gt;
&lt;li&gt;输入Commit Message点击Commit&lt;/li&gt;
&lt;li&gt;如果是第一次上传直接push，填写地址，然后输入账号密码就好了&lt;/li&gt;
&lt;li&gt;如果是协同的话记得先pull解决冲突再push&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;其实搭建博客和git没什么太大关系，只要有github账号就可以了，但是既然提到了就简单了解一下git和github&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>

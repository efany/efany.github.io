<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>efan的个人博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-03-14T17:36:41.913Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>efan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试题数据结构学习笔记</title>
    <link href="http://yoursite.com/2016/03/14/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/03/14/面试题数据结构学习笔记/</id>
    <published>2016-03-14T15:51:36.000Z</published>
    <updated>2016-03-14T17:36:41.913Z</updated>
    
    <content type="html">&lt;p&gt;数据结构是的大二时候学的，后来做项目的时候感觉其实应用的还挺多的，不过除了常用的基本上也都忘得差不多了，好好复习复习，查漏补缺。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;链表与数组&quot;&gt;&lt;a href=&quot;#链表与数组&quot; class=&quot;headerlink&quot; title=&quot;链表与数组&quot;&gt;&lt;/a&gt;链表与数组&lt;/h4&gt;&lt;p&gt;数组是一组具有相同类型和名称的变量的集合。这些变量称为数组的元素,每个数组元素都有一个编号,&lt;br&gt;这个编号叫做下标,我们可以通过下标来区别这些元素。数组元素的个数有时也称之为数组的长度。数组在内存中是逐个存放的，也就是说倘若数组的第一个元素在地址A,则数组第二个元素就在地址A+1。&lt;/p&gt;
&lt;p&gt;而链表则不是，链表每个节点没有相对固定的位置关系。某个节点在地址A其后的节点不一定是A+1,而在内存的其他空闲区域，呈现一种随机的状态。&lt;/p&gt;
&lt;p&gt;数组一旦显式的被申明后，其大小就固定了，不能动态进行扩充。而链表则可以，可以动态生成节点并且添加到已有的链表后面。&lt;/p&gt;
&lt;p&gt;链表灵活，但是空间和时间额外耗费较大；数组大小固定，元素位置固定，但是操作不灵活，且容易浪费空间，但是时间耗费较小，尤其是元素变化不大的时候效率很高。双向链表比单向的更灵活，但是空间耗费也更大&lt;/p&gt;
&lt;p&gt;链表的特性是在中间任意位置添加删除元素的都非常的快，不需要移动其它的元素。&lt;br&gt;通常链表每一个元素都要保存一个指向下一个元素的指针（单链表）。&lt;br&gt;双链表的化每个元素即要保存到下一个元素的指针，还要保存一个上一个元素的指针。&lt;br&gt;循环链表则把最后一个元素中保存下一个元素指针指向第一个元素。   &lt;/p&gt;
&lt;h4 id=&quot;队列和栈，出栈与入栈。&quot;&gt;&lt;a href=&quot;#队列和栈，出栈与入栈。&quot; class=&quot;headerlink&quot; title=&quot;队列和栈，出栈与入栈。&quot;&gt;&lt;/a&gt;队列和栈，出栈与入栈。&lt;/h4&gt;&lt;p&gt;栈和队列是两种特殊的线性表&lt;br&gt;1) 栈（LIFO，后进先出）&lt;br&gt;栈是一种限定只能在栈尾执行插入和删除操作的线性表。&lt;br&gt;栈的顺序存储结构：进栈/出栈操作均在数组尾部，时间复杂度=O(1);&lt;br&gt;缺陷：数组长度固定，长度不够时需扩容，消耗资源。&lt;br&gt;栈的链式存储结构：保存栈顶指针，出栈与入栈的时间复杂度=O(1)，且没有数据空间的限制&lt;br&gt;2) 队列(queue)(FIFO,先进先出)&lt;br&gt;队列的顺序存储结构：入列时间复杂度=O(1),出队列时间复杂度=O(n)&lt;br&gt;循环队列：解决出队列操作时间复杂度=O(n)的问题，队列的链式存储结构：入/出队列时间复杂度=O(1)&lt;/p&gt;
&lt;p&gt;在长度确定的情况下，用顺序存储结构；长度变化较大，用链式。&lt;/p&gt;
&lt;h4 id=&quot;字符串操作&quot;&gt;&lt;a href=&quot;#字符串操作&quot; class=&quot;headerlink&quot; title=&quot;字符串操作&quot;&gt;&lt;/a&gt;字符串操作&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;要求&lt;/th&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;字符串的连接&lt;/td&gt;
&lt;td&gt;public String concat(String str)&lt;/td&gt;
&lt;td&gt;该方法的参数为一个String类对象,作用是将参数中的字符串str连接到原来字符串的后面.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;求字符串的长度&lt;/td&gt;
&lt;td&gt;public int length()&lt;/td&gt;
&lt;td&gt;返回字串的长度,这里的长度指的是字符串中Unicode字符的数目.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;求字符串中某一位置的字符&lt;/td&gt;
&lt;td&gt;public char charAt(int index)&lt;/td&gt;
&lt;td&gt;该方法在一个特定的位置索引一个字符串,以得到字符串中指定位置的字符.值得注意的是,在字符串中第一个字符的索引是0,第二个字符的索引是1,依次类推,最后一个字符的索引是length()-1.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串的比较&lt;/td&gt;
&lt;td&gt;public int compareTo(String anotherString)&lt;/td&gt;
&lt;td&gt;其比较过程实际上是两个字符串中相同位置上的字符按Unicode中排列顺序逐个比较的结果.如果在整个比较过程中,没有发现任何不同的地方,则表明两个字符串是完全相等的,compareTo方法返回0;如果在比较过程中,发现了不同的地方,则比较过程会停下来,这时一定是两个字符串在某个位置上不相同,如果当前字符串在这个位置上的字符大于参数中的这个位置上的字符,compareTo方法返回一个大于0的整数,否则返回一个小于0的整数. &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串的比较&lt;/td&gt;
&lt;td&gt;public boolean equals(Object anObject)&lt;/td&gt;
&lt;td&gt;该方法比较两个字符串,和Character类提供的equals方法相似,因为它们都是重载Object类的方法.该方法比较当前字符串和参数字符串,在两个字符串相等的时候返回true,否则返回false.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串的比较&lt;/td&gt;
&lt;td&gt;public boolean equalsIgnoreCase(String anotherString)&lt;/td&gt;
&lt;td&gt;该方法和equals方法相似,不同的地方在于,equalsIgnoreCase方法将忽略字母大小写的区别&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;从字符串中提取子串&lt;/td&gt;
&lt;td&gt;public String substring(int beginIndex)&lt;/td&gt;
&lt;td&gt;该方法从beginIndex位置起,从当前字符串中取出剩余的字符作为一个新的字符串返回.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串的比较&lt;/td&gt;
&lt;td&gt;public String substring(int beginIndex, int endIndex)&lt;/td&gt;
&lt;td&gt;该方法从当前字符串中取出一个子串,该子串从beginIndex位置起至endIndex-1为结束.子串返的长度为endIndex-beginIndex. &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;判断字符串的前缀和后缀&lt;/td&gt;
&lt;td&gt;public boolean startsWith(String prefix)&lt;/td&gt;
&lt;td&gt;该方法用于判断当前字符串的前缀是否和参数中指定的字符串prefix一致,如果是,返回true,否则返回false.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;判断字符串的前缀和后缀&lt;/td&gt;
&lt;td&gt;public boolean startsWith(String prefix, int toffset)&lt;/td&gt;
&lt;td&gt;该方法用于判断当前字符串从toffset位置开始的子串的前缀是否和参数中指定的字符串prefix一致,如果是,返回true,否则返回false.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;判断字符串的前缀和后缀&lt;/td&gt;
&lt;td&gt;public boolean endsWith(String suffix)&lt;/td&gt;
&lt;td&gt;该方法用于判断当前字符串的后缀是否和参数中指定的字符串suffix一致,如果是,返回true,否则返回false.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串中单个字符的查找&lt;/td&gt;
&lt;td&gt;public int indexOf(int ch)&lt;/td&gt;
&lt;td&gt;该方法用于查找当前字符串中某一个特定字符ch出现的位置.该方法从头向后查找,如果在字符串中找到字符ch,则返回字符ch在字符串中第一次出现的位置;如果在整个字符串中没有找到字符ch,则返回-1. &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串中单个字符的查找&lt;/td&gt;
&lt;td&gt;public int indexOf(int ch, int fromIndex)&lt;/td&gt;
&lt;td&gt;该方法和第一种方法类似,不同的地方在于,该方法从fromIndex位置向后查找,返回的仍然是字符ch在字符串第一次出现的位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串中单个字符的查找&lt;/td&gt;
&lt;td&gt;public int lastIndexOf(int ch)&lt;/td&gt;
&lt;td&gt;该方法和第一种方法类似,不同的地方在于,该方法从字符串的末尾位置向前查找,返回的仍然是字符ch在字符串第一次出现的位置.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串中单个字符的查找&lt;/td&gt;
&lt;td&gt;public int lastIndexOf(int ch, int fromIndex)&lt;/td&gt;
&lt;td&gt;该方法和第二种方法类似,不同的地方在于,该方法从fromIndex位置向前查找,返回的仍然是字符ch在字符串第一次出现的位置.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串中子串的查找&lt;/td&gt;
&lt;td&gt;public int indexOf(String str)   public int indexOf(String str, int fromIndex)  public int lastIndexOf(String str) public int lastIndexOf(String str, int fromIndex)&lt;/td&gt;
&lt;td&gt;类似查找单个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串中字符大小写的转换&lt;/td&gt;
&lt;td&gt;public String toLowerCase()&lt;/td&gt;
&lt;td&gt;该方法将字符串中所有字符转换成小写,并返回转换后的新串.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串中子串的查找&lt;/td&gt;
&lt;td&gt;public String toUpperCase()&lt;/td&gt;
&lt;td&gt;该方法将字符串中所有字符转换成大写,并返回转换后的新串. &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串中多余空格的去除&lt;/td&gt;
&lt;td&gt;public String trim()&lt;/td&gt;
&lt;td&gt;该方法只是去掉开头和结尾的空格,并返回得到的新字符串.值得注意的是,在原来字符串中间的空格并不去掉.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串中字符的替换&lt;/td&gt;
&lt;td&gt;public String replace(char oldChar,char newChar)&lt;/td&gt;
&lt;td&gt;该方法用字符newChar替换当前字符串中所有的字符oldChar,并返回一个新的字符串.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串中字符的替换&lt;/td&gt;
&lt;td&gt;public String replaceFirst(String regex, String replacement)&lt;/td&gt;
&lt;td&gt;该方法用字符串replacement的内容替换当前字符串中遇到的第一个和字符串regex相一致的子串,并将产生的新字符串返回. &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字符串中字符的替换&lt;/td&gt;
&lt;td&gt;public String replaceAll(String regex, String replacement)&lt;/td&gt;
&lt;td&gt;该方法用字符串replacement的内容替换当前字符串中遇到的所有和字符串regex相一致的子串,并将产生的新字符串返回. &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;String、StringBuilder、StringBuffer&lt;/p&gt;
&lt;p&gt;三者在执行速度方面的比较：StringBuilder &amp;gt;  StringBuffer  &amp;gt;  String&lt;br&gt;StringBuilder：线程非安全的&lt;br&gt;StringBuffer：线程安全的&lt;br&gt;如果要操作少量的数据用 = String&lt;br&gt;单线程操作字符串缓冲区 下操作大量数据 = StringBuilder&lt;br&gt;多线程操作字符串缓冲区 下操作大量数据 = StringBuffer  &lt;/p&gt;
&lt;h4 id=&quot;Hash表的hash函数，冲突解决方法有哪些&quot;&gt;&lt;a href=&quot;#Hash表的hash函数，冲突解决方法有哪些&quot; class=&quot;headerlink&quot; title=&quot;Hash表的hash函数，冲突解决方法有哪些&quot;&gt;&lt;/a&gt;Hash表的hash函数，冲突解决方法有哪些&lt;/h4&gt;&lt;p&gt;在Hash表中，记录在表中的位置和其关键字之间存在着一种确定的关系。这样我们就能预先知道所查关键字在表中的位置，从而直接通过下标找到记录。使ASL趋近与0.&lt;/p&gt;
&lt;p&gt;哈希(Hash)函数是一个映象，即： 将关键字的集合映射到某个地址集合上，它的设置很灵活，只要这个地址集合的大小不超出允许范围即可；&lt;/p&gt;
&lt;p&gt;由于哈希函数是一个压缩映象，因此，在一般情况下，很容易产生“冲突”现象，即： key1 != key2，而  f(key1) = f(key2)。&lt;/p&gt;
&lt;p&gt;只能尽量减少冲突而不能完全避免冲突，这是因为通常关键字集合比较大，其元素包括所有可能的关键字，而地址集合的元素仅为哈希表中的地址值&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;hash构造函数&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;th&gt;适用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;直接定址法&lt;/td&gt;
&lt;td&gt;哈希函数为关键字的线性函数，H(key) = key 或者 H(key) = a ´ key + b&lt;/td&gt;
&lt;td&gt;哈希函数为关键字的线性函数，H(key) = key 或者 H(key) = a ´ key + b&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数字分析法&lt;/td&gt;
&lt;td&gt;假设关键字集合中的每个关键字都是由 s 位数字组成 (u1, u2, …,us)，分析关键字集中的全体，并从中提取分布均匀的若干位或它们的组合作为地址。&lt;/td&gt;
&lt;td&gt;能预先估计出全体关键字的每一位上各种数字出现的频度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;平方取中法&lt;/td&gt;
&lt;td&gt;以关键字的平方值的中间几位作为存储地址。求“关键字的平方值” 的目的是“扩大差别” ，同时平方值的中间各位又能受到整个关键字中各位的影响。&lt;/td&gt;
&lt;td&gt;关键字中的每一位都有某些数字重复出现频度很高的现象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;折叠法&lt;/td&gt;
&lt;td&gt;将关键字分割成若干部分，然后取它们的叠加和为哈希地址。两种叠加处理的方法：移位叠加:将分割后的几部分低位对齐相加；间界叠加:从一端沿分割界来回折叠，然后对齐相加。&lt;/td&gt;
&lt;td&gt;关键字的数字位数特别多。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;除留余数法&lt;/td&gt;
&lt;td&gt;设定哈希函数为:H(key) = key MOD p   ( p≤m )，其中， m为表长，p 为不大于 m 的素数，或是不含 20 以下的质因子&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;随机数法&lt;/td&gt;
&lt;td&gt;设定哈希函数为:H(key) = Random(key)其中，Random 为伪随机函数&lt;/td&gt;
&lt;td&gt;对长度不等的关键字构造哈希函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;冲突解决办法&lt;br&gt;1) 开放定址法：为产生冲突的关键字地址 H(key) 求得一个地址序列： H0, H1, H2, …, Hs  1≤s≤m-1，Hi = ( H(key)+di  ) MOD m，其中： i=1, 2, …, s，H(key)为哈希函数;m为哈希表长;&lt;br&gt;2) 链地址法：将所有哈希地址相同的记录都链接在同一链表中；&lt;br&gt;3) 再哈希法：构造若干个哈希函数，当发生冲突时，根据另一个哈希函数计算下一个哈希地址，直到冲突不再发生。即：Hi=Rhi(key)     i=1,2,……k，其中：Rhi——不同的哈希函数，特点：计算时间增加&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;数据结构是的大二时候学的，后来做项目的时候感觉其实应用的还挺多的，不过除了常用的基本上也都忘得差不多了，好好复习复习，查漏补缺。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试题J2SE学习笔记</title>
    <link href="http://yoursite.com/2016/03/14/%E9%9D%A2%E8%AF%95%E9%A2%98J2SE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/03/14/面试题J2SE学习笔记/</id>
    <published>2016-03-13T18:16:58.000Z</published>
    <updated>2016-03-15T16:56:03.564Z</updated>
    
    <content type="html">&lt;p&gt;这篇博文主要是关于面试中常见的J2SE题的学习笔记，哎，这一部分是我比较薄弱的地方了，不过这些知识点对于开发尤其重要，好好学习，增强自身实力，嘿嘿。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;九种基本数据类型的大小，以及他们的封装类。&quot;&gt;&lt;a href=&quot;#九种基本数据类型的大小，以及他们的封装类。&quot; class=&quot;headerlink&quot; title=&quot;九种基本数据类型的大小，以及他们的封装类。&quot;&gt;&lt;/a&gt;九种基本数据类型的大小，以及他们的封装类。&lt;/h4&gt;&lt;p&gt;基本数据类型可以分为四类，字符类型char，布尔类型boolean，空类型void以及数值类型byte、short、int、long、float、double。数值类型又可以分为整数类型byte、short、int、long和浮点数类型float、double。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;简单类型&lt;/th&gt;
&lt;th&gt;位数&lt;/th&gt;
&lt;th&gt;表示范围&lt;/th&gt;
&lt;th&gt;封装类&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;void&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;–&lt;/td&gt;
&lt;td&gt;Void&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;-128~127&lt;/td&gt;
&lt;td&gt;Byte&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;true/false&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;存储Unicode码&lt;/td&gt;
&lt;td&gt;Character&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;-32768~32767&lt;/td&gt;
&lt;td&gt;Short&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Int&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;负的2的31次方到正的2的31次方减1&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;负的2的63次方到正的2的63次方减1&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;1.4E-45~3.4028235E38&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;4.9e-324~1.8e308&lt;/td&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;Switch能否用string做参数&quot;&gt;&lt;a href=&quot;#Switch能否用string做参数&quot; class=&quot;headerlink&quot; title=&quot;Switch能否用string做参数&quot;&gt;&lt;/a&gt;Switch能否用string做参数&lt;/h4&gt;&lt;p&gt;在java7之前switch只支持byte、short、char、int、integer、enum枚举类型，java7后switch支持String作为参数了。&lt;/p&gt;
&lt;h4 id=&quot;equals与-的区别。&quot;&gt;&lt;a href=&quot;#equals与-的区别。&quot; class=&quot;headerlink&quot; title=&quot;equals与==的区别。&quot;&gt;&lt;/a&gt;equals与==的区别。&lt;/h4&gt;&lt;p&gt;==比较的是两个数据的内存地址是否相同，equals在Object类里比较的也是数据的内存地址，但是很多类都覆盖了该方法，比较的是两个数据的内存地址存储的值是否相同。对于基本类型两者效果一样，但是对于覆盖equals的类就不同了。&lt;/p&gt;
&lt;h4 id=&quot;Object有哪些公用方法？&quot;&gt;&lt;a href=&quot;#Object有哪些公用方法？&quot; class=&quot;headerlink&quot; title=&quot;Object有哪些公用方法？&quot;&gt;&lt;/a&gt;Object有哪些公用方法？&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;th&gt;简介&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;public final Class&amp;lt;? extends Object&amp;gt; getClass()&lt;/td&gt;
&lt;td&gt;Returns the runtime class of this. The returned object is the object that is locked by {@code  static synchronized} methods of the represented class.&lt;/td&gt;
&lt;td&gt;返回一个对象的运行时类。该 Class 对象是由所表示类的 static synchronized 方法锁定的对象。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;protected Object clone()&lt;/td&gt;
&lt;td&gt;Creates and returns a copy of this object.&lt;/td&gt;
&lt;td&gt;首先，使用这个方法的类必须实现java.lang.Cloneable接口，否则会抛出CloneNotSupportedException异常。Cloneable接口中不包含任何方法，所以实现它时只要在类声明中加上implements语句即可。第二个比较特殊的地方在于这个方法是protected修饰的，覆写clone()方法的时候需要写成public，才能让类外部的代码调用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public boolean equals(Object obj)&lt;/td&gt;
&lt;td&gt;Indicates whether some other object is “equal to” this one.&lt;/td&gt;
&lt;td&gt;　对于Object类的equals()方法来说，它判断调用equals()方法的引用于传进来的引用是否一致，即这两个引用是否指向的是同一个对象。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public int hashCode()&lt;/td&gt;
&lt;td&gt;Returns a hash code value for the object.&lt;/td&gt;
&lt;td&gt;当你覆写（override）了equals()方法之后，必须也覆写hashCode()方法，反之亦然。这个方法返回一个整型值（hash code value），如果两个对象被equals()方法判断为相等，那么它们就应该拥有同样的hash code。Object类的hashCode()方法为不同的对象返回不同的值，Object类的hashCode值表示的是对象的地址。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public String toString()&lt;/td&gt;
&lt;td&gt;　Returns a string representation of the object.&lt;/td&gt;
&lt;td&gt;当打印引用，如调用System.out.println()时，会自动调用对象的toString()方法，打印出引用所指的对象的toString()方法的返回值，因为每个类都直接或间接地继承自Object，因此每个类都有toString()方法。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public final void notify()&lt;/td&gt;
&lt;td&gt;Wakes up a single thread that is waiting on this object’s monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. A thread waits on an object’s monitor by calling one of the {@code wait} methods.&lt;/td&gt;
&lt;td&gt;此方法只应由作为此对象监视器的所有者的线程来调用。通过以下三种方法之一，线程可以成为此对象监视器的所有者：1.通过执行此对象的同步 (Sychronized) 实例方法。2.通过执行在此对象上进行同步的 synchronized 语句的正文。3.对于 Class 类型的对象，可以通过执行该类的同步静态方法。一次只能有一个线程拥有对象的监视器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public final void notifyAll()&lt;/td&gt;
&lt;td&gt;Causes the current thread to wait until either another thread invokes the {@link java.lang.Object#notify()} method or the {@link java.lang.Object#notifyAll()} method for this object, or a specified amount of time has elapsed.&lt;/td&gt;
&lt;td&gt;此方法只应由作为此对象监视器的所有者的线程来调用。请参阅 notify 方法，了解线程能够成为监视器所有者的方法的描述。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public final void wait(long timeout)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public final void wait(long timeout, int nanos)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;public final void wait()&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。换句话说，此方法的行为就好像它仅执行 wait(0) 调用一样。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;protected void finalize()&lt;/td&gt;
&lt;td&gt;Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the {@code finalize} method to dispose of system resources or to perform other cleanup.&lt;/td&gt;
&lt;td&gt;finalize 的常规协定是：当 JavaTM 虚拟机已确定尚未终止的任何线程无法再通过任何方法访问此对象时，将调用此方法，除非由于准备终止的其他某个对象或类的终结操作执行了某个操作。finalize 方法可以采取任何操作，其中包括再次使此对象对其他线程可用；不过，finalize 的主要目的是在不可撤消地丢弃对象之前执行清除操作。例如，表示输入/输出连接的对象的 finalize 方法可执行显式 I/O 事务，以便在永久丢弃对象之前中断连接。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;Hashcode的作用&quot;&gt;&lt;a href=&quot;#Hashcode的作用&quot; class=&quot;headerlink&quot; title=&quot;Hashcode的作用&quot;&gt;&lt;/a&gt;Hashcode的作用&lt;/h4&gt;&lt;p&gt;1、hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；&lt;br&gt;2、如果两个对象相同，就是适用于equals(java.lang.Object)方法，那么这两个对象的hashCode一定要相同；&lt;br&gt;3、如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；&lt;br&gt;4、两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。&lt;/p&gt;
&lt;p&gt;再归纳一下就是hashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的。&lt;/p&gt;
&lt;h4 id=&quot;ArrayList、LinkedList、Vector、Stack的区别&quot;&gt;&lt;a href=&quot;#ArrayList、LinkedList、Vector、Stack的区别&quot; class=&quot;headerlink&quot; title=&quot;ArrayList、LinkedList、Vector、Stack的区别&quot;&gt;&lt;/a&gt;ArrayList、LinkedList、Vector、Stack的区别&lt;/h4&gt;&lt;p&gt;ArrayList 是一个可改变大小的数组.当更多的元素加入到ArrayList中时,其大小将会动态地增长.内部的元素可以直接通过get与set方法进行访问,因为ArrayList本质上就是一个数组.&lt;br&gt;LinkedList 是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.&lt;br&gt;当然,这些对比都是指数据量很大或者操作很频繁的情况下的对比,如果数据和运算量很小,那么对比将失去意义.&lt;br&gt;Vector 和ArrayList类似,但属于强同步类。如果你的程序本身是线程安全的(thread-safe,没有在多个线程之间共享同一个集合/对象),那么使用ArrayList是更好的选择。&lt;br&gt;Vector和ArrayList在更多元素添加进来时会请求更大的空间。Vector每次请求其大小的双倍空间，而ArrayList每次对size增长50%.&lt;br&gt;Stack类：继承自Vector，实现一个后进先出的栈。提供了几个基本方法，push、pop、peak、empty、search等。&lt;br&gt;而 LinkedList 还实现了 Queue 接口,该接口比List提供了更多的方法,包括 offer(),peek(),poll()等.&lt;br&gt;注意: 默认情况下ArrayList的初始容量非常小,所以如果可以预估数据量的话,分配一个较大的初始值属于最佳实践,这样可以减少调整大小的开销。&lt;/p&gt;
&lt;h4 id=&quot;Map、Set、List、Queue&quot;&gt;&lt;a href=&quot;#Map、Set、List、Queue&quot; class=&quot;headerlink&quot; title=&quot;Map、Set、List、Queue&quot;&gt;&lt;/a&gt;Map、Set、List、Queue&lt;/h4&gt;&lt;p&gt;1) Collection&lt;br&gt;一组”对立”的元素，通常这些元素都服从某种规则&lt;br&gt; 　　1.1) List必须保持元素特定的顺序&lt;br&gt; 　　1.2) Set不能有重复元素&lt;br&gt; 　　1.3) Queue保持一个队列(先进先出)的顺序&lt;br&gt;2) Map&lt;br&gt;一组成对的”键值对”对象  &lt;/p&gt;
&lt;p&gt;列表（List）的主要特征是其对象以线性方式存储，没有特定顺序，只有一个开头和一个结尾，当然，它与根本没有顺序的Set是不同的。它是链表嘛，一条链肯定有顺序这个顺序就不一定了。&lt;/p&gt;
&lt;p&gt;集（set）是最简单的一种集合，它的对象不按特定方式排序，只是简单的把对象加入集合中，就像往口袋里放东西。对集中成员的访问和操作是通过集中对象的引用进行的，所以集中不能有重复对象。我们知道数学上的集合也是Set这个，集合里面一定是没有重复的元素的。 &lt;/p&gt;
&lt;p&gt;队列（Queue）在jdk5.0以前，通常的实现方式是使用java.util.List集合来模仿Queue。Queue的概念通过把对象添加（称为enqueuing的操作）到List的尾部（即Queue的后部）并通过从List的头部（即Queue的前部）提取对象而从 List中移除（称为dequeuing的操作）来模拟。你需要执行先进先出的动作时可以直接使用Queue接口就可以了。  &lt;/p&gt;
&lt;p&gt;映射（Map），这个在java里不是地图的意思，其实地图也是映射哈。它里面的东西是键－值对（key-value）出现的，键值对是什么呢？举个例子，比如我们查字典，用部首查字法。目录那个字就是键，这个字的解释就是值。键和值成对出现。这样说可以理解吧。这也是很常用的数据结构哦。 &lt;/p&gt;
&lt;h4 id=&quot;HashMap和HashTable&quot;&gt;&lt;a href=&quot;#HashMap和HashTable&quot; class=&quot;headerlink&quot; title=&quot;HashMap和HashTable&quot;&gt;&lt;/a&gt;HashMap和HashTable&lt;/h4&gt;&lt;p&gt;HashTable和HashMap区别&lt;/p&gt;
&lt;p&gt;第一，继承不同。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Hashtable extends Dictionary implements Map&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class HashMap  extends AbstractMap implements Map&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;第二&lt;/p&gt;
&lt;p&gt;Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。&lt;/p&gt;
&lt;p&gt;第三&lt;/p&gt;
&lt;p&gt;Hashtable中，key和value都不允许出现null值。&lt;/p&gt;
&lt;p&gt;在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。&lt;/p&gt;
&lt;p&gt;第四，两个遍历方式的内部实现上不同。&lt;/p&gt;
&lt;p&gt;Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。&lt;/p&gt;
&lt;p&gt;第五&lt;/p&gt;
&lt;p&gt;哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。&lt;/p&gt;
&lt;p&gt;第六&lt;/p&gt;
&lt;p&gt;Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 &lt;/p&gt;
&lt;h4 id=&quot;HashMap和ConcurrentHashMap的区别&quot;&gt;&lt;a href=&quot;#HashMap和ConcurrentHashMap的区别&quot; class=&quot;headerlink&quot; title=&quot;HashMap和ConcurrentHashMap的区别&quot;&gt;&lt;/a&gt;HashMap和ConcurrentHashMap的区别&lt;/h4&gt;&lt;p&gt;ConcurrentHashMap是线程安全的，ConcurrentHashMap具体是怎么实现线程安全的呢，肯定不可能是每个方法加synchronized，那样就变成了HashTable。&lt;br&gt;从ConcurrentHashMap代码中可以看出，它引入了一个“分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中。&lt;br&gt;在ConcurrentHashMap中，就是把Map分成了N个Segment，put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中&lt;/p&gt;
&lt;h4 id=&quot;TreeMap、HashMap、LindedHashMap&quot;&gt;&lt;a href=&quot;#TreeMap、HashMap、LindedHashMap&quot; class=&quot;headerlink&quot; title=&quot;TreeMap、HashMap、LindedHashMap&quot;&gt;&lt;/a&gt;TreeMap、HashMap、LindedHashMap&lt;/h4&gt;&lt;p&gt;TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。    &lt;/p&gt;
&lt;p&gt;Hashmap 是一个最常用的Map,它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。               &lt;/p&gt;
&lt;p&gt;LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。&lt;/p&gt;
&lt;h4 id=&quot;Collection与Collections&quot;&gt;&lt;a href=&quot;#Collection与Collections&quot; class=&quot;headerlink&quot; title=&quot;Collection与Collections&quot;&gt;&lt;/a&gt;Collection与Collections&lt;/h4&gt;&lt;p&gt;java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。继承与他的接口主要有Set 、List和Queue.&lt;/p&gt;
&lt;p&gt;java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。     &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文主要是关于面试中常见的J2SE题的学习笔记，哎，这一部分是我比较薄弱的地方了，不过这些知识点对于开发尤其重要，好好学习，增强自身实力，嘿嘿。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试题Android学习笔记</title>
    <link href="http://yoursite.com/2016/03/12/%E9%9D%A2%E8%AF%95%E9%A2%98Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/03/12/面试题Android学习笔记/</id>
    <published>2016-03-12T13:54:24.000Z</published>
    <updated>2016-03-14T14:16:27.119Z</updated>
    
    <content type="html">&lt;p&gt;这段时间一边要忙着几个项目，一边还得忙着找实习，有空就得多看看面试题，恶补一下基础知识。之前一直都是用各种第三方库，导致基础知识严重不足，这段时间好好恶补下，我也不想特别功利的背知识点，就尽可能去好好理解学习，顺便就写点学习笔记什么的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;Android的消息机制&quot;&gt;&lt;a href=&quot;#Android的消息机制&quot; class=&quot;headerlink&quot; title=&quot;Android的消息机制&quot;&gt;&lt;/a&gt;Android的消息机制&lt;/h4&gt;&lt;hr&gt;
&lt;h5 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h5&gt;&lt;p&gt;Android的消息处理机制主要是指Handler的运行机制以及附带的MessageQueue和Looper的工作过程。再加上一个ThreadLocal的用法。&lt;/p&gt;
&lt;h5 id=&quot;Handler&quot;&gt;&lt;a href=&quot;#Handler&quot; class=&quot;headerlink&quot; title=&quot;Handler&quot;&gt;&lt;/a&gt;Handler&lt;/h5&gt;&lt;p&gt;A Handler allows you to send and process Message and Runnable objects associated with a thread’s MessageQueue. Each Handler instance is associated with a single thread and that thread’s message queue. When you create a new Handler, it is bound to the thread / message queue of the thread that is creating it – from that point on, it will deliver messages and runnables to that message queue and execute them as they come out of the message queue.&lt;/p&gt;
&lt;p&gt;There are two main uses for a Handler: (1) to schedule messages and runnables to be executed as some point in the future; and (2) to enqueue an action to be performed on a different thread than your own.&lt;/p&gt;
&lt;p&gt;Handler的主要是发送（send）和接收消息（Message）与发送（post）和接收Runable，其实就是都是对于Message的操作，因为post（Runable）时也是实现了发送了一条Callback为Runable的Message来实现的。&lt;/p&gt;
&lt;p&gt;handler的send和post方法都是向消息队列（MessageQueue）插入了一条消息（Message），然后MessageQueue的next方法就返回这条消息给Looper，Looper收到消息后交给Handler处理。&lt;/p&gt;
&lt;h5 id=&quot;Message与MessageQueue&quot;&gt;&lt;a href=&quot;#Message与MessageQueue&quot; class=&quot;headerlink&quot; title=&quot;Message与MessageQueue&quot;&gt;&lt;/a&gt;Message与MessageQueue&lt;/h5&gt;&lt;p&gt;Message是线程之间传递信息的载体，包含了对消息的描述和任意的数据对象。Message中包含了两个额外的 int字段和一个object字段，这样在大部分情况下，使用者就不需要再做内存分配工作了。虽然Message的构造函数是public的，但是最好是使用Message.obtain( )或Handler.obtainMessage( )函数来获取Message对象，因为Message的实现中包含了回收再利用的机制，可以提供效率。&lt;/p&gt;
&lt;p&gt;MessageQueue是指消息队列，是一个单链表，因为方便插入与读取，插入和读取对应的方法是enqueueMessage和next，其中next是一个无限循环，如果队列中没有消息，那么next机会阻塞在哪里，当有新消息就返回消息并且从队列中移除。&lt;/p&gt;
&lt;h5 id=&quot;Looper&quot;&gt;&lt;a href=&quot;#Looper&quot; class=&quot;headerlink&quot; title=&quot;Looper&quot;&gt;&lt;/a&gt;Looper&lt;/h5&gt;&lt;p&gt;Looper实现的事消息循环的功能，会不停的查看MessageQueue中是否有新消息，如果有新消息就立刻处理。Handler的工作必须有Looper，使用Looper.prepare()可以为线程创建一个Looper，接着使用Looper.loop()来开启消息循环。在ActivityThread中默认执行了prepareMainLooper()方法，&lt;/p&gt;
&lt;h5 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h5&gt;&lt;p&gt;Implements a thread-local storage, that is, a variable for which each thread has its own value. All threads share the same ThreadLocal object, but each sees a different value when accessing it, and changes made by one thread do not affect the other threads. The implementation supports null values.&lt;/p&gt;
&lt;p&gt;ThreadLocal是一个线程内部的数据存储类，它存在的意义就在于如果没有这样一个类，那么多个线程同时访问一个数据就可能出现不可预料的情况，相对于锁机制的时间换空间,ThreadLocal相当于空间换时间，有其优势。&lt;/p&gt;
&lt;p&gt;ThreadLocal实现原理就是对于每一个数据建立了一个Object[]   table数组，每次存放读取都是操作线程相对应的数据。&lt;/p&gt;
&lt;h4 id=&quot;Android的进程、线程和线程池&quot;&gt;&lt;a href=&quot;#Android的进程、线程和线程池&quot; class=&quot;headerlink&quot; title=&quot;Android的进程、线程和线程池&quot;&gt;&lt;/a&gt;Android的进程、线程和线程池&lt;/h4&gt;&lt;hr&gt;
&lt;h5 id=&quot;进程与线程的区别和联系&quot;&gt;&lt;a href=&quot;#进程与线程的区别和联系&quot; class=&quot;headerlink&quot; title=&quot;进程与线程的区别和联系&quot;&gt;&lt;/a&gt;进程与线程的区别和联系&lt;/h5&gt;&lt;p&gt;进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.&lt;/p&gt;
&lt;p&gt;线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.&lt;/p&gt;
&lt;p&gt;一个进程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行。相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。在串行程序基础上引入线程和进程是为了提高程序的并发度，从而提高程序运行效率和响应时间。&lt;/p&gt;
&lt;p&gt;进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。&lt;br&gt;1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.&lt;br&gt;2) 线程的划分尺度小于进程，使得多线程程序的并发性高。&lt;br&gt;3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。&lt;br&gt;4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。&lt;br&gt;5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。&lt;/p&gt;
&lt;h5 id=&quot;AsyncTask&quot;&gt;&lt;a href=&quot;#AsyncTask&quot; class=&quot;headerlink&quot; title=&quot;AsyncTask&quot;&gt;&lt;/a&gt;AsyncTask&lt;/h5&gt;&lt;p&gt;AsyncTask是一种轻量级的异步任务类型，它可以再线程池中执行后台任务，然后把执行的进度和结果传递给主线程并更新UI，AsyncTask封装了Thread和Handler，并且通过AsyncTask可以很方便的执行后台任务并且在主线程中访问UI。&lt;/p&gt;
&lt;p&gt;必须在主线程中加载，对象必须在UI线程中调用，只能执行一次，Android1.6前是串行执行任务，1.6~3.0是采用在线程池了并行执行，3.0后改为串行执行，但是通过executeOnExecuter()可以并行执行。&lt;/p&gt;
&lt;h5 id=&quot;HandlerThread&quot;&gt;&lt;a href=&quot;#HandlerThread&quot; class=&quot;headerlink&quot; title=&quot;HandlerThread&quot;&gt;&lt;/a&gt;HandlerThread&lt;/h5&gt;&lt;p&gt;HandlerThread继承了Thread，它是一种可以使用Handler的Thread。&lt;/p&gt;
&lt;h5 id=&quot;IntentService&quot;&gt;&lt;a href=&quot;#IntentService&quot; class=&quot;headerlink&quot; title=&quot;IntentService&quot;&gt;&lt;/a&gt;IntentService&lt;/h5&gt;&lt;p&gt;IntentService是一个特殊的Service，IntentService可用于执行后台耗时的任务，由于它是一个服务，所以优先级比较高，不容易被杀死，IntentService封装了HandlerThread和Handler&lt;/p&gt;
&lt;h5 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h5&gt;&lt;p&gt;1) 重用线程池中的线程，避免线程因为创建和销毁所带来的性能开销&lt;br&gt;2) 能有效的控制线程池的最大并发数，避免大量的线程因相互抢占系统资源而导致的堵塞现象&lt;br&gt;3) 能够对线程进行简单的管理，并提供定时执行和制定间隔循环执行等功能&lt;/p&gt;
&lt;p&gt;######ThreadPoolExecutor&lt;br&gt;是线程池的真正实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;corePoolSize - 池中所保存的线程数，包括空闲线程。&lt;br&gt;maximumPoolSize - 池中允许的最大线程数。&lt;br&gt;keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。&lt;br&gt;unit - keepAliveTime 参数的时间单位。&lt;br&gt;workQueue - 执行前用于保持任务的队列。此队列仅保持由 execute 方法提交的 Runnable 任务。&lt;br&gt;threadFactory - 线程工厂，为线程池提供创建新线程的功能。&lt;br&gt;handler - 当线程池无法执行新任务的时候，会调用handler的rejectedExecutionException来通知调用者。&lt;/p&gt;
&lt;h6 id=&quot;FixedThreadPool&quot;&gt;&lt;a href=&quot;#FixedThreadPool&quot; class=&quot;headerlink&quot; title=&quot;FixedThreadPool&quot;&gt;&lt;/a&gt;FixedThreadPool&lt;/h6&gt;&lt;p&gt;是一种线程数量固定的线程池，当线程处于空闲状态时，不会被回收，并且没有超时机制，所以能够快速的响应外界的请求。&lt;/p&gt;
&lt;h6 id=&quot;CachedThreadPool&quot;&gt;&lt;a href=&quot;#CachedThreadPool&quot; class=&quot;headerlink&quot; title=&quot;CachedThreadPool&quot;&gt;&lt;/a&gt;CachedThreadPool&lt;/h6&gt;&lt;p&gt;没有核心线程，但是可以创建任意多个非核心线程，超时时长为60秒。&lt;/p&gt;
&lt;h6 id=&quot;ScheduledThreadPool&quot;&gt;&lt;a href=&quot;#ScheduledThreadPool&quot; class=&quot;headerlink&quot; title=&quot;ScheduledThreadPool&quot;&gt;&lt;/a&gt;ScheduledThreadPool&lt;/h6&gt;&lt;p&gt;核心线程数固定，非核心线程数量无限制，超时时长为，意味着非核心一旦闲置就被回收。&lt;/p&gt;
&lt;h6 id=&quot;SingleThreadExector&quot;&gt;&lt;a href=&quot;#SingleThreadExector&quot; class=&quot;headerlink&quot; title=&quot;SingleThreadExector&quot;&gt;&lt;/a&gt;SingleThreadExector&lt;/h6&gt;&lt;p&gt;只有一个核心线程，是的所有任务顺序执行。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这段时间一边要忙着几个项目，一边还得忙着找实习，有空就得多看看面试题，恶补一下基础知识。之前一直都是用各种第三方库，导致基础知识严重不足，这段时间好好恶补下，我也不想特别功利的背知识点，就尽可能去好好理解学习，顺便就写点学习笔记什么的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>个人博客搭建之Github篇</title>
    <link href="http://yoursite.com/2016/03/11/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B9%8BGithub%E7%AF%87/"/>
    <id>http://yoursite.com/2016/03/11/个人博客搭建之Github篇/</id>
    <published>2016-03-11T14:34:34.000Z</published>
    <updated>2016-03-13T16:32:29.679Z</updated>
    
    <content type="html">&lt;p&gt;其实搭建博客和git没什么太大关系，只要有github账号就可以了，但是既然提到了就简单了解一下git和github&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;术语&quot;&gt;&lt;a href=&quot;#术语&quot; class=&quot;headerlink&quot; title=&quot;术语&quot;&gt;&lt;/a&gt;术语&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;术语&lt;/th&gt;
&lt;th&gt;定义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;仓库 Repository&lt;/td&gt;
&lt;td&gt;一个仓库包括了所有的版本信息、所有的分支和标记信息.在Git中仓库的每份拷贝都是完整的。仓库让你可以从中取得你的工作副本。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;分支 Branches&lt;/td&gt;
&lt;td&gt;一个分支意味着一个独立的、拥有自己历史信息的代码线分支（codeline）。你可以从已有的代码中生成一个新的分支，这个分支与剩余的分支完全独立。默认的分支往往是叫master。用户可以选择一个分支，选择一个分支叫做checkout.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;标记 Tags&lt;/td&gt;
&lt;td&gt;一个标记指的是某个分支某个特定时间点的状态。通过标记，可以很方便的切换到标记时的状态，例如2009年1月25号在testing分支上的代码状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;提交 Commit&lt;/td&gt;
&lt;td&gt;提交代码后，仓库会创建一个新的版本。这个版本可以在后续被重新获得。每次提交都包括作者和提交者，作者和提交者可以是不同的人&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;URL&lt;/td&gt;
&lt;td&gt;URl用来标识一个仓库的位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;修订 Revision&lt;/td&gt;
&lt;td&gt;用来表示代码的一个版本状态。Git通过用SHA1 hash算法表示的id来标识不同的版本。每一个 SHA1 id都是160位长,16进制标识的字符串.最新的版本可以通过HEAD来获取.之前的版本可以通过”HEAD~1”来获取，以此类推。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;忽略特定的文件&quot;&gt;&lt;a href=&quot;#忽略特定的文件&quot; class=&quot;headerlink&quot; title=&quot;忽略特定的文件&quot;&gt;&lt;/a&gt;忽略特定的文件&lt;/h2&gt;&lt;p&gt;可以配置Git忽略特定的文件或者是文件夹。这些配置都放在.gitignore文件中。这个文件可以存在于不同的文件夹中，可以包含不同的文件匹配模式。为了让Git忽略bin文件夹，在主目录下放置.gitignore文件，其中内容为bin。&lt;br&gt;同时Git也提供了全局的配置，core.excludesfile。&lt;br&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;*.iml&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.gradle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/local.properties&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/.idea/workspace.xml&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/.idea/libraries&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.DS_Store&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/build&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/captures&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;具体的git教程参照&lt;a href=&quot;http://blog.csdn.net/lishuo_os_ds/article/details/8078475#sec-1/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub详细教程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Android-Studio的git功能&quot;&gt;&lt;a href=&quot;#Android-Studio的git功能&quot; class=&quot;headerlink&quot; title=&quot;Android Studio的git功能&quot;&gt;&lt;/a&gt;Android Studio的git功能&lt;/h2&gt;&lt;h6 id=&quot;1-注册github账号&quot;&gt;&lt;a href=&quot;#1-注册github账号&quot; class=&quot;headerlink&quot; title=&quot;1.注册github账号&quot;&gt;&lt;/a&gt;1.注册github账号&lt;/h6&gt;&lt;p&gt;自行百度 Google&lt;/p&gt;
&lt;h6 id=&quot;1-下载安装git&quot;&gt;&lt;a href=&quot;#1-下载安装git&quot; class=&quot;headerlink&quot; title=&quot;1.下载安装git&quot;&gt;&lt;/a&gt;1.下载安装git&lt;/h6&gt;&lt;p&gt;地址：&lt;a href=&quot;https://git-scm.com/downloads&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://git-scm.com/downloads&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&quot;2-匹配到AS&quot;&gt;&lt;a href=&quot;#2-匹配到AS&quot; class=&quot;headerlink&quot; title=&quot;2.匹配到AS&quot;&gt;&lt;/a&gt;2.匹配到AS&lt;/h6&gt;&lt;p&gt;File–&amp;gt;Setting–&amp;gt;Version Control–&amp;gt;Git–&amp;gt;PAth to Git executable:&lt;/p&gt;
&lt;p&gt;注意是Git/bin/git.exe&lt;/p&gt;
&lt;h6 id=&quot;3-使用&quot;&gt;&lt;a href=&quot;#3-使用&quot; class=&quot;headerlink&quot; title=&quot;3.使用&quot;&gt;&lt;/a&gt;3.使用&lt;/h6&gt;&lt;ol&gt;
&lt;li&gt;VCS–&amp;gt;enable….–&amp;gt;选择git&lt;/li&gt;
&lt;li&gt;右击工程（注意选到project目录模式）或者VCS–&amp;gt;Git–&amp;gt;add&lt;/li&gt;
&lt;li&gt;Git–&amp;gt;commit Directory–&amp;gt;选择要上传的文件&lt;/li&gt;
&lt;li&gt;输入Commit Message点击Commit&lt;/li&gt;
&lt;li&gt;如果是第一次上传直接push，填写地址，然后输入账号密码就好了&lt;/li&gt;
&lt;li&gt;如果是协同的话记得先pull解决冲突再push&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;其实搭建博客和git没什么太大关系，只要有github账号就可以了，但是既然提到了就简单了解一下git和github&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
